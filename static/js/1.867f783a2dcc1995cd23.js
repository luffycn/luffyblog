webpackJsonp([1],{"9bIa":function(e,n,t){"use strict";var o={render:function(){var e=this,n=e.$createElement,t=e._self._c||n;return t("div",{staticClass:"right-content"},[t("div",{staticClass:"zhuanti pc-border-hover"},[t("h2",{staticClass:"hometitle"},[e._v("特别推荐")]),e._v(" "),t("ul",e._l(e.spc,function(n,o){return t("li",{key:o},[t("i",{staticClass:"pc-opacity"},[t("img",{attrs:{src:n.imgUrl}})]),e._v(" "),t("p",[e._v("\n          "+e._s(n.title)+"\n          "),t("span",{staticClass:"shaling"},[t("a",{attrs:{href:n.url}},[e._v("阅读")])])])])}))]),e._v(" "),t("div",{staticClass:"zhuanti pc-border-hover"},[t("h2",{staticClass:"hometitle"},[e._v("点击排行")]),e._v(" "),t("ul",[t("li",[t("i",{staticClass:"pc-hover"},[t("img",{attrs:{src:e.spccli.first.imgUrl}})]),e._v(" "),t("h3",{staticClass:"first-title"},[e._v(e._s(e.spccli.first.title))])])]),e._v(" "),t("ul",{staticClass:"sidenews"},e._l(e.spccli.othe,function(n,o){return t("li",{key:o},[t("i",{staticClass:"pc-hover"},[t("img",{attrs:{src:n.imgUrl}})]),e._v(" "),t("h4",[t("a",{attrs:{href:""}},[e._v(e._s(n.title))])]),e._v(" "),t("span",[e._v(e._s(n.time))])])}))])])},staticRenderFns:[]};var r=t("VU/8")({name:"rightContent",data:function(){return{spc:[{imgUrl:"./static/imges/banner01.jpg",title:"VUE资源集合",url:""},{imgUrl:"./static/imges/text01.jpg",title:"动画特效demo",url:""},{imgUrl:"./static/imges/b07.jpg",title:"cavas绘画",url:""}],spccli:{first:{imgUrl:"./static/imges/text01.jpg",title:"移动web开放注意事项",url:""},othe:[{imgUrl:"./static/imges/11.jpg",title:"formitable中文API",time:"2017-06-13",url:""},{imgUrl:"./static/imges/b06.jpg",title:"vue脚手架正确流程",time:"2017-11-22",url:""},{imgUrl:"./static/imges/text02.jpg",title:"动画特效demo",time:"2018-05-07",url:""}]}}},mounted:function(){}},o,!1,function(e){t("Z97u")},"data-v-0b78d1ac",null);n.a=r.exports},Z97u:function(e,n){},hguN:function(e,n,t){"use strict";var o={name:"textContent",data:function(){return{}},props:{textData:{type:Object}},mounted:function(){}},r={render:function(){var e=this,n=e.$createElement,t=e._self._c||n;return t("div",{staticClass:"text-content"},[t("router-link",{attrs:{to:{name:"arcontent",params:e.textData}}},[t("div",{staticClass:"text-box"},[t("h1",[e._v(e._s(e.textData.title))]),e._v(" "),"noImg"!=e.textData.imgType?t("div",{class:"bigImg"==e.textData.imgType?"big-img pc-opacity":"sm-img pc-hover"},[t("img",{attrs:{src:e.textData.imgUrl}})]):e._e(),e._v(" "),t("p",[e._v(e._s(e.textData.mes))]),e._v(" "),t("p",{staticClass:"messe"},[t("i",{staticClass:"iconfont icon-yonghu01"}),e._v(e._s(e.textData.user)+"\n        "),t("i",{staticClass:"iconfont icon-icon"}),e._v(e._s(e.textData.textType)+"\n        "),t("i",{staticClass:"iconfont icon-shijian"}),e._v(e._s(e.textData.creatTime)+"\n        "),t("i",{staticClass:"iconfont icon-yuedu"}),e._v(e._s(e.textData.reader)+"已阅读\n        "),t("i",{staticClass:"iconfont icon-dianzan21"}),e._v(e._s(e.textData.great)+"\n      ")])])])],1)},staticRenderFns:[]};var s=t("VU/8")(o,r,!1,function(e){t("ppvn")},"data-v-aeb8b4ea",null);n.a=s.exports},j7bC:function(e,n){},ppvn:function(e,n){},vTuG:function(e,n,t){"use strict";n.a=function(e,n,t,o){!(arguments.length>4&&void 0!==arguments[4])||arguments[4];switch(n){case"/home/getPageData":o(r)}};var o="user-select:text;word-break:break-all;display:block;font-size:.08rem;line-height:22px;overflow-x:auto;white-space:pre;word-wrap:break-word;border-radius:4px;padding:8px;background:#f3dcb3a8",r={carData:[{img:"./static/imges/banner02.jpg",title:"vuex详解",mes:"\n        vuex是什么？\n        先引用vuex官网的话：\n        Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。\n        状态管理模式、集中式存储管理 一听就很高大上，蛮吓人的。在我看来 vuex 就是把需要共享的变量全部存储在一个对象里面，然后将这个对象放在顶层组件中供其他组件使用。这么说吧，将vue想作是一个js文件、组件是函数，那么vuex就是一个全局变量，只是这个“全局变量”包含了一些特定的规则而已。\n        在vue的组件化开发中，经常会遇到需要将当前组件的状态传递给其他组件。父子组件通信时，我们通常会采用 props + emit 这种方式。但当通信双方不是父子组件甚至压根不存在相关联系，或者一个状态需要共享给多个组件时，就会非常麻烦，数据也会相当难维护，这对我们开发来讲就很不友好。vuex 这个时候就很实用，不过在使用vuex之后也带来了更多的概念和框架，需慎重！\n        vuex里面都有些什么内容？\n        Talk is cheap,Show me the code. 先来一段代码间隔下这么多的文字：\n        <code style="+o+">\n        const store = new Vuex.Store({\n            state: {\n                name: 'weish',\n                age: 22\n            },\n            getters: {\n                personInfo(state) {\n                    return 'My name is &yen;{state.name}, I am &yen;{state.age}';\n                }\n            }\n            mutations: {\n                SET_AGE(state, age) {\n                    commit(age, age);\n                }\n            },\n            actions: {\n                nameAsyn({commit}) {\n                    setTimeout(() => {\n                        commit('SET_AGE', 18);\n                    }, 1000);\n                }\n            },\n            modules: {\n                a: modulesA\n            }\n        }\n        <code>\n        这个就是最基本也是完整的vuex代码；vuex 包含有五个基本的对象：\n        \n        state：存储状态。也就是变量；\n        getters：派生状态。也就是set、get中的get，有两个可选参数：state、getters分别可以获取state中的变量和其他的getters。外部调用方式：store.getters.personInfo()。就和vue的computed差不多；\n        mutations：提交状态修改。也就是set、get中的set，这是vuex中唯一修改state的方式，但不支持异步操作。第一个参数默认是state。外部调用方式：store.commit('SET_AGE', 18)。和vue中的methods类似。\n        actions：和mutations类似。不过actions支持异步操作。第一个参数默认是和store具有相同参数属性的对象。外部调用方式：store.dispatch('nameAsyn')。\n        modules：store的子模块，内容就相当于是store的一个实例。调用方式和前面介绍的相似，只是要加上当前子模块名，如：store.a.getters.xxx()。\n        vue-cli中使用vuex的方式\n        一般来讲，我们都会采用vue-cli来进行实际的开发，在vue-cli中，开发和调用方式稍微不同。\n        \n        ├── index.html\n        ├── main.js\n        ├── components\n        └── store\n            ├── index.js          # 我们组装模块并导出 store 的地方\n            ├── state.js          # 跟级别的 state\n            ├── getters.js        # 跟级别的 getter\n            ├── mutation-types.js # 根级别的mutations名称（官方推荐mutions方法名使用大写）\n            ├── mutations.js      # 根级别的 mutation\n            ├── actions.js        # 根级别的 action\n            └── modules\n                ├── m1.js         # 模块1\n                └── m2.js         # 模块2\n        state.js示例：\n        \n        const state = {\n            name: 'weish',\n            age: 22\n        };\n        \n        export default state;\n        getters.js示例（我们一般使用getters来获取state的状态，而不是直接使用state）：\n        \n        export const name = (state) => {\n            return state.name;\n        }\n        \n        export const age = (state) => {\n            return state.age\n        }\n        \n        export const other = (state) => {\n            return 'My name is &yen;{state.name}, I am &yen;{state.age}.';\n        }\n        mutation-type.js示例（我们会将所有mutations的函数名放在这个文件里）：\n        \n        export const SET_NAME = 'SET_NAME';\n        export const SET_AGE = 'SET_AGE';\n        mutations.js示例：\n        \n        import * as types from './mutation-type.js';\n        \n        export default {\n            [types.SET_NAME](state, name) {\n                state.name = name;\n            },\n            [types.SET_AGE](state, age) {\n                state.age = age;\n            }\n        };\n        actions.js示例（异步操作、多个commit时）：\n        \n        import * as types from './mutation-type.js';\n        \n        export default {\n            nameAsyn({commit}, {age, name}) {\n                commit(types.SET_NAME, name);\n                commit(types.SET_AGE, age);\n            }\n        };\n        modules--m1.js示例（如果不是很复杂的应用，一般来讲是不会分模块的）：\n        \n        export default {\n            state: {},\n            getters: {},\n            mutations: {},\n            actions: {}\n        };\n        index.js示例（组装vuex）：\n        \n        import vue from 'vue';\n        import vuex from 'vuex';\n        import state from './state.js';\n        import * as getters from './getters.js';\n        import mutations from './mutations.js';\n        import actions from './actions.js';\n        import m1 from './modules/m1.js';\n        import m2 from './modules/m2.js';\n        import createLogger from 'vuex/dist/logger'; // 修改日志\n        \n        vue.use(vuex);\n        \n        const debug = process.env.NODE_ENV !== 'production'; // 开发环境中为true，否则为false\n        \n        export default new vuex.Store({\n            state,\n            getters,\n            mutations,\n            actions,\n            modules: {\n                m1,\n                m2\n            },\n            plugins: debug ? [createLogger()] : [] // 开发环境下显示vuex的状态修改\n        });\n        最后将store实例挂载到main.js里面的vue上去就行了\n        \n        import store from './store/index.js';\n        \n        new Vue({\n          el: '#app',\n          store,\n          render: h => h(App)\n        });\n        在vue组件中使用时，我们通常会使用mapGetters、mapActions、mapMutations，然后就可以按照vue调用methods和computed的方式去调用这些变量或函数，示例如下：\n        \n        import {mapGetters, mapMutations, mapActions} from 'vuex';\n        \n        /* 只写组件中的script部分 */\n        export default {\n            computed: {\n                ...mapGetters([\n                    name,\n                    age\n                ])\n            },\n            methods: {\n                ...mapMutations({\n                    setName: 'SET_NAME',\n                    setAge: 'SET_AGE'\n                }),\n                ...mapActions([\n                    nameAsyn\n                ])\n            }\n        };\n        总结\n        以上就是vuex 的相关知识，其实vuex很简单，多用几次就会熟悉了。\n        \n        "},{img:"./static/imges/banner01.jpg",title:"移动web开发注意事项",mes:"\n        这有一篇总结的很全的文章,就直接拿过来方便以后看吧...\n        <a href='www.baidu.com'>https://www.cnblogs.com/baihuaxiu/p/6654496.html</a>"},{img:"./static/imges/toppic02.jpg",title:"vue-router 基本使用",mes:"\n            　  路由，其实就是指向的意思，当我点击页面上的home按钮时，页面中就要显示home的内容，如果点击页面上的about 按钮，页面中就要显示about 的内容。Home按钮  => home 内容， about按钮 => about 内容，也可以说是一种映射. 所以在页面上有两个部分，一个是点击部分，一个是点击之后，显示内容的部分,点击之后，怎么做到正确的对应，比如，我点击home 按钮，页面中怎么就正好能显示home的内容。这就要在js 文件中配置路由。。\n                <code style="+o+'>\n　　路由中有三个基本的概念 route, routes, router。\n\n　　　　1， route，它是一条路由，由这个英文单词也可以看出来，它是单数， Home按钮  => home内容， 这是一条route,  about按钮 => about 内容， 这是另一条路由。\n\n　　　　2， routes 是一组路由，把上面的每一条路由组合起来，形成一个数组。[{home 按钮 =>home内容 }， { about按钮 => about 内容}]\n\n　　　　3， router 是一个机制，相当于一个管理者，它来管理路由。因为routes 只是定义了一组路由，它放在哪里是静止的，当真正来了请求，怎么办？ 就是当用户点击home 按钮的时候，怎么办？这时router 就起作用了，它到routes 中去查找，去找到对应的 home 内容，所以页面中就显示了 home 内容。\n\n　　　　4，客户端中的路由，实际上就是dom 元素的显示和隐藏。当页面中显示home 内容的时候，about 中的内容全部隐藏，反之也是一样。客户端路由有两种实现方式：基于hash 和基于html5 history api.\n\n　　vue-router中的路由也是基于上面的内容来实现的\n\n　　在vue中实现路由还是相对简单的。因为我们页面中所有内容都是组件化的，我们只要把路径和组件对应起来就可以了，然后在页面中把组件渲染出来。\n\n　　1， 页面实现（html模版中）\n\n　　　　在vue-router中, 我们看到它定义了两个标签<router-link> 和<router-view>来对应点击和显示部分。<router-link> 就是定义页面中点击的部分，<router-view> 定义显示部分，就是点击后，区配的内容显示在什么地方。所以 <router-link> 还有一个非常重要的属性 to，定义点击之后，要到哪里去， 如：<router-link  to="/home">Home</router-link>\n\n　　2， js 中配置路由\n\n　　　　首先要定义route,  一条路由的实现。它是一个对象，由两个部分组成： path和component.  path 指路径，component 指的是组件。如：{path:’/home’, component: home}\n\n　　　　我们这里有两条路由，组成一个routes: \n\nconst routes = [\n  { path: \'/home\', component: Home },\n  { path: \'/about\', component: About }\n]\n　　最后创建router 对路由进行管理，它是由构造函数 new vueRouter() 创建，接受routes 参数。\n\nconst router = new VueRouter({\n      routes // routes: routes 的简写\n})\n　　配置完成后，把router 实例注入到 vue 根实例中,就可以使用路由了\n\nconst app = new Vue({\n  router\n}).$mount(\'#app\')\n　　执行过程：当用户点击 router-link 标签时，会去寻找它的 to 属性， 它的 to 属性和 js 中配置的路径{ path: \'/home\', component: Home}  path 一一对应，从而找到了匹配的组件， 最后把组件渲染到 <router-view> 标签所在的地方。所有的这些实现才是基于hash 实现的。\n\n vue-cli 创建一个项目体验一下, 当然不要忘记安装vue-router\n\n　　1, 在src 目录下新建两个组件，home.vue 和 about.vue\n\n\n<template>\n    <div>\n        <h1>home</h1>\n        <p>{{msg}}</p>\n    </div>\n</template>\n<script>\n    export default {\n        data () {\n            return {\n                msg: "我是home 组件"\n            }\n        }\n    }\n<\/script>\n\n\n<template>\n    <div>\n        <h1>about</h1>\n        <p>{{aboutMsg}}</p>\n    </div>\n</template>\n<script>\n    export default {\n        data () {\n            return {\n                aboutMsg: \'我是about组件\'\n            }\n        }\n    }\n<\/script>\n\n　　2, 在 App.vue中 定义<router-link > 和 </router-view>  \n\n\n<template>\n  <div id="app">\n    <img src="./assets/logo.png">\n    <header>\n    \x3c!-- router-link 定义点击后导航到哪个路径下 --\x3e\n      <router-link to="/home">Home</router-link>\n      <router-link to="/about">About</router-link>\n    </header>\n    \x3c!-- 对应的组件内容渲染到router-view中 --\x3e\n    <router-view></router-view>   \n  </div>\n</template>\n\n<script>\nexport default {\n  \n}\n<\/script>\n\n　　3,  在 src目录下再新建一个router.js 定义router, 就是定义 路径到 组件的 映射。\n\n\nimport Vue from "vue";\nimport VueRouter from "vue-router";\n\n// 引入组件\nimport home from "./home.vue";\nimport about from "./about.vue";\n\n// 要告诉 vue 使用 vueRouter\nVue.use(VueRouter);\n\nconst routes = [\n    {\n        path:"/home",\n        component: home\n    },\n    {\n        path: "/about",\n        component: about\n    }\n]\n\nvar router =  new VueRouter({\n    routes\n})\nexport default router;\n\n　　4， 把路由注入到根实例中，启动路由。这里其实还有一种方法，就像vuex  store 注入到根实例中一样，我们也可以把vueRouter 直接注入到根实例中。在main.js中引入路由，注入到根实例中。\n\n\nimport Vue from \'vue\'\nimport App from \'./App.vue\'\n\n// 引入路由\nimport router from "./router.js"    // import router 的router 一定要小写， 不要写成Router, 否则报 can\'t match的报错\nnew Vue({\n  el: \'#app\',\n  router,  // 注入到根实例中\n  render: h => h(App)\n})\n\n　　5， 这时点击页面上的home 和about 可以看到组件来回切换。但是有一个问题，当首次进入页面的时候，页面中并没有显示任何内容。这是因为首次进入页面时，它的路径是 \'/\'，我们并没有给这个路径做相应的配置。一般，页面一加载进来都会显示home页面，我们也要把这个路径指向home组件。但是如果我们写{ path: \'/\', component: Home },vue 会报错，因为两条路径却指向同一个方向。这怎么办？这需要重定向，所谓重定向，就是重新给它指定一个方向，它本来是访问 / 路径，我们重新指向‘/home’, 它就相当于访问 \'/home\', 相应地, home组件就会显示到页面上。vueRouter中用 redirect 来定义重定向。\n\n\nconst routes = [\n    {\n        path:"/home",\n        component: home\n    },\n    {\n        path: "/about",\n        component: about\n    },\n    // 重定向\n    {\n        path: \'/\', \n        redirect: \'/home\' \n    }\n]\n\n　　现在页面正常了，首次进入显示home, 并且点击也可以看到内容的切换。\n\n6， 最后，我们看一下路由是怎么实现的\n\n　　打开浏览器控制台，首先看到 router-link 标签渲染成了 a 标签，to 属性变成了a 标签的 href 属性，这时就明白了点击跳转的意思。router-view 标签渲染成了我们定义的组件，其实它就是一个占位符，它在什么地方，匹配路径的组件就在什么地方，所以 router-link 和router-view 标签一一对应，成对出现。\n\n\n\n　　这里还看到，当点击Home和About 来回切换时，a 标签有一个样式类 .router-link-active 也在来回切换， 原来这是当router-link 处于选中状态时，vueRouter 会自动添加这个类，因此我们也可以利用这个类来改变选中时的状态，如选中时，让它变成红色。但当设置 .router-link-active {color: red;}，它并没有生效，这时还要在类前面加一个a, a.router-link-active {color: red;}, 这样就没有问题了。未处于选中状态的router-link， 我们也想给它更改样式，怎么办? 直接给它添加一个 class 就可以了， <router-link class="red">Home</router-link>\n\n动态路由\n\n　　上面我们定义的路由，都是严格匹配的，只有router-link 中的to属性和 js 中一条路由route中 path 一模一样，才能显示相应的组件component. 但有时现实却不是这样的，当我们去访问网站并登录成功后，它会显示 欢迎你，+ 你的名字。不同的用户登录， 只是显示“你的名字” 部分不同，其它部分是一样的。这就表示，它是一个组件，假设是user组件。不同的用户（就是用户的id不同），它都会导航到同一个user  组件中。这样我们在配置路由的时候，就不能写死, 就是路由中的path属性，不能写死，那要怎么设置? 导航到 user 组件，路径中肯定有user, id 不同，那就给路径一个动态部分来匹配不同的id.  在vue-router中，动态部分 以 : 开头，那么路径就变成了 /user/:id, 这条路由就可以这么写：  { path:"/user/:id", component: user }.\n\n　　我们定义一个user组件（自己随便写一个就好了），页面中再添加两个router-link 用于导航， 最后router.js中添加路由配置，来体验一下\n\n　　app.vue 中添加两个router-link：\n\n\n<template>\n  <div id="app">\n    <img src="./assets/logo.png">\n    <header>\n      <router-link to="/home">Home</router-link>\n      <router-link to="/about">About</router-link>\n     \x3c!--  增加两个到user组件的导航，可以看到这里使用了不同的to属性 --\x3e\n      <router-link to="/user/123">User123</router-link>\n      <router-link to="/user/456">User456</router-link>\n    </header>\n    <router-view></router-view>   \n  </div>\n</template>\n\nrouter.js 配置user动态路由：\n\n\nconst routes = [\n    {\n        path:"/home",\n        component: home\n    },\n    {\n        path: "/about",\n        component: about\n    },\n    /*新增user路径，配置了动态的id*/\n    {\n        path: "/user/:id",\n        component: user\n    },\n    {\n        path: \'/\', \n        redirect: \'/home\' \n    }\n]\n\n　　user组件\n\n\n<template>\n    <div>\n        <h1>User</h1>\n        <div>我是user组件</div>\n    </div>\n</template>\n<script>\n    export default {\n\n    }\n<\/script>\n\n　　这时在页面中点击user123 和user456, 可以看到它们都导航到user组件，配置正确。 　　\n\n　　在动态路由中，怎么获取到动态部分？ 因为在组件中是可以显示不同部分的，就是上面提到的“你的名字”。其实，当整个vue-router 注入到根实例后，在组件的内部，可以通过this.$route 来获取到 router 实例。它有一个params 属性，就是来获得这个动态部分的。它是一个对象，属性名，就是路径中定义的动态部分 id, 属性值就是router-link中to 属性中的动态部分，如123。使用vuex时，组件中想要获取到state 中的状态，是用computed 属性，在这里也是一样，在组件中，定义一个computed 属性dynamicSegment， user 组件修改如下：\n\n\n<template>\n    <div>\n        <h1>User</h1>\n        <div>我是user组件, 动态部分是{{dynamicSegment}}</div>\n    </div>\n</template>\n<script>\n    export default {\n        computed: {\n            dynamicSegment () {\n                return this.$route.params.id\n            }\n        }\n    }\n<\/script>\n\n　　这里还有最后一个问题，就是动态路由在来回切换时，由于它们都是指向同一组件，vue不会销毁再创建这个组件，而是复用这个组件，就是当第一次点击（如：user123）的时候，vue 把对应的组件渲染出来，但在user123, user456点击来回切换的时候，这个组件就不会发生变化了，组件的生命周期不管用了。这时如果想要在组件来回切换的时候做点事情，那么只能在组件内部（user.vue中）利用watch 来监听$route 的变化。把上面的代码用监听$route 实现\n\n\n<script>\n    export default {\n        data () {\n            return {\n                dynamicSegment: \'\'\n            }\n        },\n        watch: {\n            $route (to,from){\n                // to表示的是你要去的那个组件，from 表示的是你从哪个组件过来的，它们是两个对象，你可以把它打印出来，它们也有一个param 属性\n                console.log(to);\n                console.log(from);\n                this.dynamicSegment = to.params.id\n            }\n        }\n    }\n<\/script>\n\n嵌套路由\n\n　　嵌套路由，主要是由我们的页面结构所决定的。当我们进入到home页面的时候，它下面还有分类，如手机系列，平板系列，电脑系列。当我们点击各个分类的时候，它还是需要路由到各个部分，如点击手机，它肯定到对应到手机的部分。\n\n　　在路由的设计上，首先进入到 home ,然后才能进入到phone, tablet, computer.  Phone, tablet, compute 就相当于进入到了home的子元素。所以vue  提供了childrens 属性，它也是一组路由,相当于我们所写的routes。\n\n　　首先，在home页面上定义三个router-link 标签用于导航，然后再定义一个router-view标签，用于渲染对应的组件。router-link 和router-view 标签要一一对应。home.vue 组件修改如下：\n\n\n<template>\n    <div>\n        <h1>home</h1>\n\x3c!-- router-link 的to属性要注意，路由是先进入到home,然后才进入相应的子路由如 phone,所以书写时要把 home 带上 --\x3e\n        <p>\n            <router-link to="/home/phone">手机</router-link>\n            <router-link to="/home/tablet">平板</router-link>\n            <router-link to="/home/computer">电脑</router-link>\n        </p>\n        <router-view></router-view>\n    </div>\n</template>\n\nrouter.js 配置路由，修改如下：\n\n\nconst routes = [\n    {\n        path:"/home",\n　　　　　// 下面这个属性也不少，因为，我们是先进入home页面，才能进入子路由\n        component: home,\n　　　　 // 子路由\n        children: [\n            {\n                path: "phone",\n                component: phone\n            },\n            {\n                path: "tablet",\n                component: tablet\n            },\n            {\n                path: "computer",\n                component: computer\n            }\n        ]\n    },\n    {\n        path: "/about",\n        component: about\n    },\n    {\n        path: "/user/:id",\n        component: user\n    },\n    {\n        path: \'/\', \n        redirect: \'/home\' \n    }\n]\n\n　　这时当我们点击home 时，它下面出现手机等字样，但没有任何对应的组件进行显示，这通常不是我们想要的。要想点击home时，要想渲染相对应的子组件，那还需要配置一条路由。当进入到home 时，它在children中对应的路由path 是空 ‘’，完整的childrens 如下：\n\n\nchildren: [\n    {\n        path: "phone",\n        component: phone\n    },\n    {\n        path: "tablet",\n        component: tablet\n    },\n    {\n        path: "computer",\n        component: computer\n    },\n    // 当进入到home时，下面的组件显示\n    {\n        path: "",\n        component: phone\n    }\n]\n\n命名路由\n\n　　命名路由，很简单，因为根据名字就可以知道，这个路由有一个名字，那就直接给这个路由加一个name 属性，就可以了。 给user 路由加一个name 属性：\n\n{\n        path: "/user/:id",\n        name: "user",\n        component: user\n}\n　　命名路由的使用, 在router-link 中to 属性就可以使用对象了, \n\n <router-link to="/user/123">User123</router-link> // 和下面等价 \n <router-link :to="{ name: \'user\', params: { userId: 123 }}">User</router-link>   // 当使用对象作为路由的时候，to前面要加一个冒号,表示绑定\n　　编程式导航：这主要应用到按钮点击上。当点击按钮的时候，跳转另一个组件, 这只能用代码，调用rourter.push() 方法。 当们把router 注入到根实例中后，组件中通过 this.$router 可以获取到router, 所以在组件中使用\n\nthis.$router.push("home"), 就可以跳转到home界面\n                <code>\n            '}],spcData:{img:["./static/imges/toppic01.jpg","./static/imges/b05.jpg"],mes:["flex弹性盒子布局","常用正则表达式"],router:[]},listData:[{title:"Node.js 搭建使用流程",imgType:"smImg",imgUrl:"./static/imges/v2.jpg",mes:"作为一个从业三年左右的，并且从事过半年左右JAVA开发工作的前端，对于后台，尤其是对以js语言进行开发的nodejs，那是比较有兴趣的，所以再次记录一下原生写法(不用express)方便以后复习！\n            今天主要记录一下，很久以前用nodejs制作一个简单的服务监听程序的一些过程！\n            <code style="+o+">var http = require('http');\n            http.createServer(function (req, res) {\n              res.writeHead(200, {'Content-Type': 'text/plain'});\n              res.end('Hello World');\n            }).listen(1337, '127.0.0.1');\n            console.log('Server running at http://127.0.0.1:1337/');\n            </code>\n            大家都知道，通过nodejs可以对前台请求进行监听，这里就放一个官网的hello world例子吧：\n            以上代码相信了解过node的童鞋应该都会比较熟悉！\n            那么node既然可以监听请求，那么是不是就可以根据前台的不同请求返回不同的文件或内容？这不就是一个简单的服务器了么！抱着这样的想法，简单实验了一下，我们都知道，服务器可以根据请求的文件不同，会使用相应mine类型的！比如../index.css使用的mine类型就是text/css！那么，我们是不是应该有个常用mine类型的一个简单配置？这里，做了个简单的mine配置文件mine.js，用json来存放一下常用的格式：\n            <code style="+o+'>\n            exports.types = {\n                "css": "text/css",\n                "gif": "image/gif",\n                "html": "text/html",\n                "ico": "image/x-icon",\n                "jpeg": "image/jpeg",\n                "jpg": "image/jpeg",\n                "js": "text/javascript",\n                "json": "application/json",\n                "pdf": "application/pdf",\n                "png": "image/png",\n                "svg": "image/svg+xml",\n                "swf": "application/x-shockwave-flash",\n                "tiff": "image/tiff",\n                "txt": "text/plain",\n                "wav": "audio/x-wav",\n                "wma": "audio/x-ms-wma",\n                "wmv": "video/x-ms-wmv",\n                "xml": "text/xml"\n            };\n            </code>\n            当然，除了这些以外还有很多其他格式，这里就不一一举例了！\n            好了，有了mine格式对应的文件配置文件，接下来就简单了，首先得根据官网例子搭建一个监听程序，然后在监听程序中添加一下简单的www.baidu.com/这个样的链接默认打开文件的处理，以及相对链接的补全等！当然还得做一下简单的错误处理，如404，500等！具体看代码：\n            <code style='+o+">\n            /*\n            *搭建http服务器，监听http请求\n            */\n            var http = require(\"http\"),\n            fs = require('fs'),\n            path = require('path'),\n            mine = require('./mine').types;\n            url = require('url');\n            //定义简单的工具\n            //获取当前时间\n            var date = function(ms) {\n                var date = ms ? new Date(ms) : new Date(),\n                mon = date.getMonth() >= 10 + 1 ? '-' : '-0',\n                d = date.getDate() >= 10 ? '-' : '-0',\n                hour = date.getHours() >= 10 ? ' ' : ' 0',\n                min = date.getMinutes() >= 10 ? ':' : ':0',\n                sec = date.getSeconds() >= 10 ? ':' : ':0';\n                return date.getFullYear() + mon + (date.getMonth() + 1) + d + date.getDate() + hour + date.getHours() + min + date.getMinutes() + sec + date.getSeconds();\n            },\n            //定义输出log日志方法，带上时间，方便调试\n            DebugLog = function(mes) {\n                var now = date();\n                console.log(now + \" \" + mes);\n            };\n            //服务监听\n            exports.server = function() {\n                http.createServer(function(req, res) {\n                    var pathname = url.parse(req.url).pathname,//获取url中的文件名\n                    pathname = (pathname !== \"/\" && pathname) ? pathname : \"/index.html\";//处理链接以'/'结尾的情况\n                    var realPath = path.join(\"../\", path.normalize(pathname.replace(/../g, \"\"))),//将链接转换成物理路径\n                    ext = path.extname(realPath);\n                    ext = ext ? ext.slice(1) : 'unknown';//获取文件扩展名\n                    //查找文件\n                    fs.exists(realPath, function (exists) {\n                        if (!exists) {//处理404\n                            res.writeHead(404, {\n                                'Content-Type': 'text/plain'\n                            });\n            \n                            res.write(\"This request URL \" + pathname + \" was not found on this server.\");\n                            res.end();\n                        } else {//读取文件\n                            fs.readFile(realPath, \"binary\", function (err, file) {\n                                if (err) {//程序出错报500错误\n                                    res.writeHead(500, {\n                                        'Content-Type': 'text/plain'\n                                    });\n                                    res.end(err);\n                                } else {//正常返回文件\n                                    var contentType = mine[ext] || \"text/plain\";//根据mine.js中的配置设置对应的contentType\n                                    res.writeHead(200, {\n                                        'Content-Type': contentType\n                                    });\n                                    res.write(file, \"binary\");\n                                    res.end();\n                                }\n                            });     \n                        }\n                    });\n                }).listen(8888, 'localhost');\n                tool.DebugLog(\"http服务启动，开始监听127.0.0.1:8888的http请求！\");\n            }\n            </code>        \n            ok，代码到这里基本就结束了，当然这只是最简单的功能，大家可以自己去丰富！\n            ",user:"Luffy",textType:"学无止境",creatTime:"2017-6-13",reader:3441,great:9999},{title:"个人常用",imgType:"bigImg",imgUrl:"./static/imges/t01.jpg",mes:"\n            <code style="+o+">\n            初始化样式\n                body,ol,ul,h1,h2,h3,h4,h5,h6,p,th,td,dl,dd,form,fieldset,legend,input,textarea,select{margin:0;padding:0;user-select: none;}    \n                html,body{font-size: 100px;;width: 100%;height: 100%;overflow: hidden;width: 100%;-webkit-tap-highlight-color: rgba(0, 0, 0, 0);}    \n                /* html,body{font-family: 'HansHandItalic';font-size: 100px;;width: 100%;height: 100%;overflow: hidden;}     */\n                a{text-decoration:none}    \n                em{font-style:normal}    \n                li{list-style:none}    \n                img{border:0;}    \n                table{border-collapse:collapse;border-spacing:0}    \n                p{word-wrap:break-word}   \n                iframe{border: none}\n            \n            配置本地接口路由代理node\n                proxyTable: {\n                    '/node': {\n                    target: 'http://192.168.0.69:4000',\n                    changeOrigin: true,\n                    pathRewrite: {\n                        '^/node': ''\n                    }\n                },\n                },\n\n                // Various Dev Server settings\n                host: '192.168.0.69', // can be overwritten by process.env.HOST\n                \n\n                                \n            VUE配置全局样式\n                build/utils.js下面配置\n                scss: generateLoaders('sass').concat(\n                    {\n                        loader: 'sass-resources-loader',\n                        options: {\n                        resources: path.resolve(__dirname, '../themes/gy.scss')\n                        }\n                    }\n                    ),\n\n                sass-resources-loader 记得install 依赖\n\n\n\n\n\n                2201817617   ★QQ\n\n\n                            \n\n            wnidow.addEventListener('touchmove', func, { passive: false})   移动端阻止默认事件\n\n\n            通过设置css属性 -webkit-tap-highlight-color: rgba(0, 0, 0, 0);取消掉手机端webkit浏览器 点击按钮或超链接之类的 默认灰色背景色 \n            区域性 overflow: scroll | auto 滚动时使用原生效果：-webkit-overflow-scrolling: touch （ios8+，Android4.0+）\n            \n\n\n\n            pointer-events:none  /  auto      事件冒泡点击\n            opacity:0     元素透明度\n\n            radial-gradient(circle, #666 10%, transparent 10.01%)\n            circle = 指定圆形的径向渐变\n\n\n            transition:width 3s    过渡效果\n\n\n            transform: scale(10, 10); 放大   rotate(360deg);旋转2d\n\n\n            :active   点击激活后触发CSS\n\n            transparent 100%  颜色透明\n\n\n            animation: always-movie infinite  linear   动画名称，几秒，永动，匀速运动\n\n            let a=[\"a\",\"b\",\"c\",\"d\",\"e\",\"f\",\"g\"]\n                a.forEach((listVal)=>{\n                    console.log(listVal);\n                })\n\n\n            display:flex   布局属性 https://www.cnblogs.com/qingchunshiguang/p/8011103.html\n\n\n            http://www.php.cn/course/600.html    ES6\n\n\n            <style scoped>  局部范围样式\n\n            display: -webkit-box;\n                    -webkit-box-orient: vertical;\n                    -webkit-line-clamp: 2;\n                    text-overflow: ellipsis;\n                    overflow: hidden;                指定行数文本溢出处理\n\n\n            https://www.cnblogs.com/qingchunshiguang/p/8011103.html   布局属性\n            https://blog.csdn.net/ermaner666/article/details/78995234    vue脚手架正确流程\n            https://www.cnblogs.com/SamWeb/p/6610733.html              vue路由详解\n            https://segmentfault.com/a/1190000012015742                     vuex详解\n            https://blog.csdn.net/u012860063/article/details/68063919    vue全家桶学习资源\n            https://www.jb51.net/article/113003.htm                               vux样式库组件配置安装\n            https://www.cnblogs.com/baihuaxiu/p/6654496.html            移动web开放注意事项\n            https://www.jb51.net/tools/zhengze.html                              正则表达式\n            http://bbs.boniu6668.com/thread-35195-1-1.html                 常用正则表达式\n            http://www.17sucai.com/pins/tag/3886.html                         花了5块钱的！！！\n            https://www.cnblogs.com/yuanke/archive/2016/02/26/5221853.html     formitable中文API\n            https://blog.csdn.net/hjh15827475896/article/details/78207066  VUE资源集合\n\n\n            https://tinypng.com/           图片压缩网站\n            .\n\n            https://www.bilibili.com/video/av19641847/?p=2                   node\n\n            <code>\n            ",user:"Luffy",textType:"享受生活",creatTime:"2018-7-13",reader:8888,great:9999},{title:"Flex弹性盒子",imgType:"noImg",imgUrl:"",mes:"啊啊啊f，else if 来判断，输出。思路已打开，样式调用就可以多样化啦来判断，输出。思路已打开，样式调用就可以多样化啦",user:"Luffy",textType:"学无止境",creatTime:"2016-11-13",reader:8888,great:9999},{title:"node环境mongoDB基础使用",imgType:"smImg",imgUrl:"./static/imges/zd02.jpg",mes:"、增加标签模板，用if，else if 来判断，输出。思路已打开，样式调用就可以多样化啦来判断，输出。思路已打开，样式调用就可以多样化啦",user:"Luffy",textType:"学无止境",creatTime:"2017-4-13",reader:2367,great:9999},{title:"Noade.js 搭建使用流程",imgType:"smImg",imgUrl:"./static/imges/v2.jpg",mes:"如图，要实现上图效果，我采用如下方法：1、首先在数据库模型，增加字段，分别是图片2，图片3。2、增加标签模板，用if，else if 来判断，输出。思路已打开，样式调用就可以多样化啦来判断，输出。思路已打开，样式调用就可以多样化啦",user:"Luffy",textType:"学无止境",creatTime:"2017-6-13",reader:3441,great:9999},{title:"Just do it",imgType:"bigImg",imgUrl:"./static/imges/t01.jpg",mes:"增加标签模板，用if，else if 来判断，输出签模板，用if，else if 来判断，输出。思路已打开，样式调用就可以多样化啦来判断，输出。思路已打开，样式调用就可以多样化啦",user:"Luffy",textType:"享受生活",creatTime:"2018-7-13",reader:8888,great:9999},{title:"Flex弹性盒子",imgType:"noImg",imgUrl:"",mes:"啊啊啊f，else if 来判断，输出。思路已打开，样式调用就可以多样化啦来判断，输出。思路已打开，样式调用就可以多样化啦",user:"Luffy",textType:"学无止境",creatTime:"2016-11-13",reader:8888,great:9999},{title:"node环境mongoDB基础使用",imgType:"smImg",imgUrl:"./static/imges/zd02.jpg",mes:"、增加标签模板，用if，else if 来判断，输出。思路已打开，样式调用就可以多样化啦来判断，输出。思路已打开，样式调用就可以多样化啦",user:"Luffy",textType:"学无止境",creatTime:"2017-4-13",reader:2367,great:9999}]}},"x/Iy":function(e,n,t){"use strict";Object.defineProperty(n,"__esModule",{value:!0});var o=t("hguN"),r=t("9bIa"),s=t("vTuG"),a={name:"study",data:function(){return{carimges:[],adpics:{},textContentData:[],isReady:!1}},components:{textContent:o.a,rightContent:r.a},mounted:function(){var e=this;Object(s.a)("get","/home/getPageData","",function(n){e.carimges=n.carData,e.adpics=n.spcData,e.textContentData=n.listData,e.isReady=!0})}},i={render:function(){var e=this.$createElement,n=this._self._c||e;return this.isReady?n("div",{staticClass:"study"},[n("div",{staticClass:"comtent-box"},[n("div",{staticClass:"right-box"},[n("right-content")],1),this._v(" "),this._l(this.textContentData,function(e,t){return n("text-content",{key:t,attrs:{textData:e}})}),this._v(" "),n("div",{staticClass:"lk"})],2)]):this._e()},staticRenderFns:[]};var u=t("VU/8")(a,i,!1,function(e){t("j7bC")},"data-v-0d3f483e",null);n.default=u.exports}});
//# sourceMappingURL=1.867f783a2dcc1995cd23.js.map